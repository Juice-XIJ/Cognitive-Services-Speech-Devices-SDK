package com.microsoft.coginitiveservices.speech.samples.sdsdkstarterapp;import android.content.Intent;import android.content.res.AssetManager;import android.os.AsyncTask;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.text.Layout;import android.text.TextUtils;import android.text.method.ScrollingMovementMethod;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.WindowManager;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.EditText;import android.widget.ListView;import android.widget.TextView;import com.microsoft.cognitiveservices.speech.ConversationTranscriber;import com.microsoft.cognitiveservices.speech.Participant;import com.microsoft.cognitiveservices.speech.SpeechConfig;import com.microsoft.cognitiveservices.speech.User;import com.microsoft.cognitiveservices.speech.audio.AudioConfig;import org.json.JSONArray;import org.json.JSONObject;import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.DataOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.io.InputStreamReader;import java.math.BigInteger;import java.net.HttpURLConnection;import java.net.URI;import java.net.URL;import java.util.ArrayList;import java.util.HashMap;import java.util.Random;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.TimeoutException;import static com.microsoft.coginitiveservices.speech.samples.sdsdkstarterapp.LanguageCode.getCode;public class enrollment extends AppCompatActivity {    private HashMap<String, Float[]> signatureMap = new HashMap<>();    private Button enrollButton;    private Button meetingButton;    private ListView attendeeListView;    private EditText attendeeEditText;    private TextView meetingTextView;    private Toolbar meetingToolbar;    private static final String speakerRecognitionKey = "";    private String languageRecognition = new String();    private ArrayAdapter attendeeAdapter;    static final int SELECT_MEETING_RECOGNIZE_LANGUAGE_REQUEST = 0;    private SpeechConfig speechConfig = null;    private static final String inroomEndpoint = "wss://its.demo.princeton.customspeech.ai/speech/recognition/multiaudio?";    private static final String MeetingAudioInput= "/video/DictationBatman.wav";    private final ArrayList<String> rEvents = new ArrayList<>();    private final ArrayList<String> attendeeName = new ArrayList<>();    private final String logTag = "Meeting";    private boolean meetingStarted = false;    private ConversationTranscriber transcriber = null;    public boolean onCreateOptionsMenu(Menu menu){        getMenuInflater().inflate(R.menu.enrollmentmenu,menu);        return true;    }    public boolean onOptionsItemSelected(MenuItem item) {        switch (item.getItemId()) {            case R.id.RecoLanguage: {                Intent selectLanguageIntent = new Intent(this, listLanguage.class);                selectLanguageIntent.putExtra("RecognizeOrTranslate", 0);                startActivityForResult(selectLanguageIntent, SELECT_MEETING_RECOGNIZE_LANGUAGE_REQUEST);                return true;            }            case R.id.back: {                startActivity(new Intent(getApplicationContext(), MainActivity.class).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP));                return true;            }            default:                return super.onContextItemSelected(item);        }    }    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_enrollment);        Toolbar toolbar = (Toolbar) findViewById(R.id.meetingToolbar);        enrollButton = findViewById(R.id.enrollButton);        meetingButton = findViewById(R.id.meetingButton);        attendeeListView = findViewById(R.id.attendeeListView);        attendeeEditText = findViewById(R.id.attendeeEditText);        meetingTextView = findViewById(R.id.meetingTextView);        meetingTextView.setMovementMethod(new ScrollingMovementMethod());        meetingToolbar = (Toolbar) findViewById(R.id.meetingToolbar);        setSupportActionBar(meetingToolbar);        setSupportActionBar(toolbar);        languageRecognition = "en-US";        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);        attendeeAdapter = new ArrayAdapter(this, android.R.layout.simple_list_item_1, attendeeName);        attendeeListView.setAdapter(attendeeAdapter);        attendeeListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {            @Override            public void onItemClick(AdapterView<?> parent, final View view,                                    int position, long id) {                final String item = (String) parent.getItemAtPosition(position);                attendeeName.remove(position);                signatureMap.remove(item);                attendeeAdapter.notifyDataSetChanged();                setRecognizedText("remove " + item);            }        });        enrollButton.setOnClickListener(view ->{            enrollButton.setEnabled(false);            clearTextBox();            String fileName =attendeeEditText.getText().toString();            if(fileName.length() == 0){                setRecognizedText("Please input audio file path");            }else{                File wavFile = new File(fileName);                if(wavFile.exists()) {                    String userId = wavFile.getName();                    new enrollTask().execute(userId.substring(0, userId.length()-4), fileName);                }else{                    setRecognizedText(fileName + " does not exist");                }            }        });        meetingButton.setOnClickListener(view ->{            ///////////////////////////////////////////////////            // check if we have a valid key            ///////////////////////////////////////////////////            disableButtons();            meetingTextView.setText("");            if (meetingStarted) {                stopClicked();                meetingStarted = false;                return;            }                clearTextBox();            if (!MainActivity.checkSpeechKey()) {                meetingTextView.setText("Warning: Please update SpeechSubscriptionKey with your actual subscription key!");                return;            }            if(signatureMap.size() == 0){                meetingTextView.setText("Please enroll the meeting attendee first!");            }else{                //speechConfig = MainActivity.getSpeechConfig();                speechConfig = SpeechConfig.fromEndpoint(URI.create(inroomEndpoint), "");                if(new File(MeetingAudioInput).exists()) {                    try {                        AssetManager assetManager = getAssets();                        //WavFileAudioInputStream ais = new WavFileAudioInputStream(assetManager, MeetingAudioInput);                        WavFileAudioInputStream ais = new WavFileAudioInputStream(assetManager, "whatstheweatherlike_8channels.wav");                        transcriber = new ConversationTranscriber(speechConfig, AudioConfig.fromStreamInput(ais));                        transcriber.setConversationId("MeetingTest");                        // add by user Id                        for(String userId:signatureMap.keySet()){                            User user = User.fromUserId(userId);                            transcriber.addParticipant(user);                            Float image[] = { 3.3f, 4.4f };                            //Log.i(logTag, "Speech Recognition Language " + speechConfig.getSpeechRecognitionLanguage());                            Participant participant = Participant.from(userId, "en-US", signatureMap.get(userId), image);                            transcriber.addParticipant(participant);                        }                        startRecognizeMeeting(transcriber);                        meetingStarted = true;                    }catch(Exception ex){                        System.out.println(ex.getMessage());                        displayException(ex);                    }                } else{                    setRecognizedText("audio file does not exist");                    return;                }            }        });    }    private void startRecognizeMeeting(ConversationTranscriber t) throws InterruptedException, ExecutionException, TimeoutException {        try {            t.recognizing.addEventListener((o, e) -> {                final String text = e.getResult().getText();                final String speakerId = e.getResult().getSpeakerId();                final String result = text + " " + speakerId + " ";                Log.i(logTag, "Intermediate result received: " + result);                rEvents.add(result);                setRecognizedText(TextUtils.join("\n", rEvents));                rEvents.remove(rEvents.size() - 1);            });            t.recognized.addEventListener((o, e) -> {                final String text = e.getResult().getText();                final String speakerId = e.getResult().getSpeakerId();                final String result = text + " " + speakerId + " ";                Log.i(logTag, "Final result received: " + result);                rEvents.add(result);                setRecognizedText(TextUtils.join(" ", rEvents));            });            rEvents.clear();            final Future<Void> task = t.startTranscribingAsync();            setOnTaskCompletedListener(task, result -> {                Log.i(logTag, "Recognition started.");                enrollment.this.runOnUiThread(() -> {                    enableButtons("Stop");                });            });        }catch (Exception ex){            System.out.println(ex.getMessage());            displayException(ex);        }    }    private void stopClicked(){        try {            final Future<Void> task = transcriber.stopTranscribingAsync();            setOnTaskCompletedListener(task, result -> {                Log.i(logTag, "Recognition stopped.");                enrollment.this.runOnUiThread(() -> {                    enableButtons("Start");                });            });        }        catch (Exception ex) {            System.out.println(ex.getMessage());            displayException(ex);        }    }    private void clearTextBox() {        appendTextLine("", true);    }    private void setRecognizedText(final String s) {        appendTextLine(s, true);    }    private void appendTextLine(final String s, final Boolean erase) {        enrollment.this.runOnUiThread(() -> {            if (erase) {                meetingTextView.setText(s);            } else {                String txt = meetingTextView.getText().toString();                meetingTextView.setText(txt + "\n" + s);            }            final Layout layout =meetingTextView.getLayout();            if(layout != null) {                int scrollDelta = layout.getLineBottom(meetingTextView.getLineCount() - 1)                        - meetingTextView.getScrollY() - meetingTextView.getHeight();                if (scrollDelta > 0)                    meetingTextView.scrollBy(0, scrollDelta);            }        });    }    protected void onActivityResult(int requestCode, int resultCode, Intent data) {        // Check which request we're responding to        if (requestCode == SELECT_MEETING_RECOGNIZE_LANGUAGE_REQUEST) {            // Make sure the request was successful            if (resultCode == RESULT_OK) {                String language = data.getStringExtra("language");                speechConfig.setSpeechRecognitionLanguage( getCode(0,language));                Log.i(logTag,language +" Recognizing");            }        }    }    private void disableButtons() {        enrollment.this.runOnUiThread(() -> {            meetingButton.setEnabled(false);        });    }    public void enableButtons(String text) {        enrollment.this.runOnUiThread(() -> {            meetingButton.setText(text);            meetingButton.setEnabled(true);        });    }    private <T> void setOnTaskCompletedListener(Future<T> task, OnTaskCompletedListener<T> listener) {        s_executorService.submit(() -> {            T result = task.get();            listener.onCompleted(result);            return null;        });    }    private interface OnTaskCompletedListener<T> {        void onCompleted(T taskResult);    }    protected static ExecutorService s_executorService;    static {        s_executorService = Executors.newCachedThreadPool();    }    private void displayException(Exception ex) {        meetingTextView.setText(ex.getMessage() + "\n" + TextUtils.join("\n", ex.getStackTrace()));    }    public class enrollTask extends AsyncTask<String, String, String> {        Float[] signatureId;        @Override        protected String doInBackground(String[] params) {            String enrollId = params[0];            try{                String lineEnd = "\r\n";                String twoHyphens = "--";                String boundary = new BigInteger(256, new Random()).toString();                File wavFile = new File(params[1]);                Log.i("Meeting", "enroll: " + enrollId + " audio file: " + wavFile.getName());                int bytesRead, bytesAvailable, bufferSize;                byte[] buffer;                int maxBufferSize = 1024 * 1024;                URL url = new URL("https://pss.princetondev.customspeech.ai/api/v1/Signature/GenerateVoiceSignatureFromFile");                HttpURLConnection connection = (HttpURLConnection) url.openConnection();                // Allow Inputs &amp; Outputs.                connection.setDoInput(true);                connection.setDoOutput(true);                connection.setUseCaches(false);                // Set HTTP method to POST.                connection.setRequestMethod("POST");                connection.setRequestProperty("accept", "application/json");                connection.setRequestProperty("Ocp-Apim-Subscription-Key", speakerRecognitionKey);                connection.setRequestProperty("Content-Type", "multipart/form-data;boundary=" + boundary);                FileInputStream fileInputStream;                DataOutputStream outputStream;                outputStream = new DataOutputStream(connection.getOutputStream());                outputStream.writeBytes(twoHyphens + boundary + lineEnd);                outputStream.writeBytes("Content-Disposition: form-data; name=\"File\";filename=\"" + wavFile.getName() +"\"" + lineEnd);                outputStream.writeBytes(lineEnd);                fileInputStream = new FileInputStream(wavFile);                bytesAvailable = fileInputStream.available();                bufferSize = Math.min(bytesAvailable, maxBufferSize);                Log.i("Meeting", "Buffer size: " + Integer.toString(bufferSize));                buffer = new byte[bufferSize];                // Read file                bytesRead = fileInputStream.read(buffer, 0, bufferSize);                int count = 1;                while (bytesRead > 0) {                    outputStream.write(buffer, 0, bufferSize);                    bytesAvailable = fileInputStream.available();                    bufferSize = Math.min(bytesAvailable, maxBufferSize);                    bytesRead = fileInputStream.read(buffer, 0, bufferSize);                }                outputStream.writeBytes("\r\n--" + boundary + "--");                // Responses from the server (code and message)                int serverResponseCode = connection.getResponseCode();                Log.i("Meeting", "serverResponseCode: " + Integer.toString(serverResponseCode));                String result = null;                if (serverResponseCode == 200) {                    StringBuilder s_buffer = new StringBuilder();                    InputStream is = new BufferedInputStream(connection.getInputStream());                    BufferedReader br = new BufferedReader(new InputStreamReader(is));                    String inputLine;                    while ((inputLine = br.readLine()) != null) {                        s_buffer.append(inputLine);                    }                    result = s_buffer.toString();                    Log.i("Meeting", "Response result: " + result);                    if (result != null) {                        JSONObject signature = new JSONObject(result);                        String status = signature.getString("Status");                        if(status.equals("OK")){                            Log.i("Meeting","Enrollment: Get Signature ID from GenerateVoiceSignatureFromFile is OK");                            JSONObject sr = signature.getJSONObject("Signature");                            JSONArray signaureArray = sr.optJSONArray("Signature");                            signatureId = new Float[signaureArray.length()];                            for(int i = 0; i< signaureArray.length(); i++){                                signatureId[i] =(float)signaureArray.getDouble(i);                            }                            signatureMap.put(enrollId, signatureId);                        }                    }                }                fileInputStream.close();                outputStream.flush();                outputStream.close();                Log.i("Meeting", "Enrollment is finished: " + enrollId);            } catch (Exception e) {                e.printStackTrace();            }            return enrollId;        }        @Override        protected void onPostExecute(String result) {            if(result.length() != 0)            {                setRecognizedText("Enrollment1 is successful");                attendeeEditText.setText("");                attendeeName.add(result);                attendeeAdapter.notifyDataSetChanged();                enrollButton.setEnabled(true);            }        }    }}